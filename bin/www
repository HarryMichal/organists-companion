#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('companion-server:server');
var http = require('http');
var https = require('https');
var fs = require('fs');
var WebSocket = require('ws');
var jwt = require('jsonwebtoken');
var sqlite3 = require('sqlite3');
var config = require('../config/config');
var url = require('url');
var database = require('../utils/database.js');
var utils = require('../utils/utilities.js');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3001');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Configure WebSocket server
 */

var db = new sqlite3.Database('./db/testdb.db', sqlite3.OPEN_READWRITE, (err) => {
 if (err) {
   console.error(err);
 };
});

var wss = new WebSocket.Server({
  'server': server,
  'path': "/api/ws",
  'clientTracking': true,
  'verifyClient': function(info, done) {
    var query = url.parse(info.req.url, true).query;
    
    // check the origin of the issued request
    if (info.origin === "http://localhost:3000" && query.token !== null) {
      jwt.verify(query.token, config.token.secret, function(err, token) {
        if (err) {
          console.error(err);
          done(false);
        }
        if (token) {
          console.log("Connection accepted.");
          done(true);
        }
        else {
          console.log("Connection rejected.");
          done(false);
        };
      }); // end of jwt.verify
    } // end of if
    else {
      console.log("Connection rejected.");
      done(false);
    }
  }
});
 
wss.getUniqueID = function() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    return '#' + s4();
};

wss.sendMessage = function(message, target) {
  switch(target) {
    case "all":
      wss.clients.forEach(function each(client) {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify(message));
        }
      });
      break;
    case "organist":
      wss.clients.forEach(function each(client) {
        if (client.chatRoom === "general") {
          client.send(JSON.stringify(message));
        }
      });
      break;
    case "guest":
      wss.clients.forEach(function each(client) {
        if (client.chatRoom === "guest") {
          client.send(JSON.stringify(message));
        }
      });
      break;
  }
}

wss.handleConnection = function(request, ws) {
  let parameters = url.parse(request.url, true);
  let token = jwt.decode(parameters.query.token);
  
  ws.id = token.sub + wss.getUniqueID();
  ws.chatRoom = token.perm;
  
  console.log(`${ws.id} has just connected.`);
}

wss.showUsers = function() {
  let clients = [];
  wss.clients.forEach(function each(client) {
    clients.push(client.id);
  });
  console.log(clients);
}

wss.handleVerses = function(verse) {
  let verses = [];
  for (var i = 0; i < verse; i++) {
    verses[i] = i + 1;
  }
  return verses;
}
 
wss.on('connection', function connection(ws, req) {
  wss.handleConnection(req, ws);
  
  wss.showUsers();
  
  database.select("type, number, verse", "meta", "id", "1", function(err, meta) {
    if (err) {
      console.error(err);
    }
    if (meta) {
      if (meta.type === "song") {
        database.select("id, verse", "songs", "id", meta.number, function(err, song) {
          if (err) {
            console.error(err);
          }
          if (song) {
            let verses = wss.handleVerses(song.verse);
            
            if (meta.verse === null) {
              var activeverse = [];
            }
            else {
              var activeverse = utils.toArray(meta.verse);
            }
            
            let message = {
              id: song.id,
              verse: verses,
              activeverse: activeverse,
              type: meta.type
            };
            wss.sendMessage(message, "all");
          }
        });
      }
      
      if (meta.type === "psalm") {
        database.select("id, text", "psalms", "id", meta.number, function(err, psalm) {
          if (err) {
            console.error(err);
          }
          if (meta) {
            let message = {
              type: meta.type,
              id: psalm.id,
              psalmtext: psalm.text
            };
            wss.sendMessage(message, "all");
          }
        });
      }
      
      if (meta.type === null) {
        let message = {
          type: "blank",
          id: "",
          verse: "",
          activeverse: []
        };
        wss.sendMessage(message, "all");
      }
    }
  });
  
  ws.on('message', function(data) {
    var data = JSON.parse(data);
    
    switch(data.type) {
      case "song":
        database.update("meta", "number = ?, type = ?, verse = ?", "id = 1", [`${data.number}`, `${data.type}`, null], function(err, changes) {
          if (err) {
            console.error(err);
          }
          if (changes) {
            database.select("type, number", "meta", "id", "1", function(err, meta) {
              if (err) {
                console.error(err);
              }
              if (meta) {
                database.select("id, verse", "songs", "id", meta.number, function(err, song) {
                  if (err) {
                    console.error(err);
                  }
                  if (song) {
                    let verses = wss.handleVerses(song.verse);
                    let message = {
                      id: song.id,
                      verse: verses,
                      activeverse: [],
                      type: meta.type
                    };
                    wss.sendMessage(message, "all");
                  }
                })
              }
            });
          }
        });
        break;
      case "psalm":
        database.update("meta", "number = ?, type = ?, verse = ?", "id = 1", [`${data.number}`, `${data.type}`, null], function(err, changes) {
          if (err) {
            console.error(err);
          }
          if (changes) {
            database.select("type, number", "meta", "id", "1", function(err, meta) {
              if (err) {
                console.error(err);
              }
              if (meta) {
                database.select("id, text", "psalms", "id", meta.number, function(err, psalm) {
                  if (err) {
                    console.error(err);
                  }
                  if (psalm) {
                    console.log(meta.type);
                    let message = {
                      type: meta.type,
                      id: psalm.id,
                      psalmtext: psalm.text
                    };
                    wss.sendMessage(message, "all");
                  }
                });
              }
            });
          }
        });
        break;
      case "verse":
        if (data.subtype === "add") {
          database.select("verse", "meta", "id", "1", function(err, meta) {
            if (err) {
              console.error(err);
            }
            if (meta) {
              var oldverse = utils.toArray(meta.verse);
              if (meta.verse == "" || meta.verse == null) {
                var verse = utils.toArray(data.verse);
              }
              else {
                var verse = oldverse.concat(parseInt(data.verse)).sort(function(a, b){return a-b});
              }
              
              database.update("meta", "verse = ?", "id = 1", [`${verse}`], function(err, changes) {
                if (err) {
                  console.error(err);
                }
                if (changes) {
                  let message = {
                    type: data.type,
                    verse: verse
                  };
                  wss.sendMessage(message, "all");
                }
              })
            }
          })
        }
        
        if (data.subtype === "del") {
          database.select("verse", "meta", "id", "1", function(err, meta) {
            if (err) {
              console.error(err);
            }
            if (meta) {
              var oldverse = utils.toArray(meta.verse);
              var todelete = oldverse.indexOf(parseInt(data.verse));
              oldverse.splice(todelete, 1);
              
              database.update("meta", "verse = ?", "id = 1", [`${oldverse}`], function(err, changes) {
                if (err) {
                  console.error(err);
                }
                if (changes) {
                  let message = {
                    type: data.type,
                    verse: oldverse
                  };
                  wss.sendMessage(message, "all");
                }
              })
            }
          })
        }
        break;
      case "blank":
        database.update("meta", "number = ?, type = ?, verse = ?", "id = 1", [null, null, null], function(err, changes) {
          if (err) {
            console.error(err)
          }
          if (changes) {
            let message = {
              id: "",
              verse: "",
              activeverse: [],
              type: "blank"
            };
            wss.sendMessage(message, "all");
          }
        })
        break;
      default:
        console.log("Received unknown message format.");
        break;
    }
  });
  
  ws.onclose = function(e) {
    console.log("Socket has been closed.");
  };
  
  ws.onerror = function(err) {
    console.error("Socket encountered error: ", err.message, " Closing socket.");
    ws.close();
  };
})

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
